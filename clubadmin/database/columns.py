'''
This module provides decorators for each of the datatypes supported by the program.

These decorators help maintain the integrity of the database and provide information to
reduce the number of columns that are updated to the minimum, without having to spread
the logic all around the program logic. It also makes it easy to make changes to the
implementation details of a single column with little if any impact on the remainder of
the logic.

The following columns are supported:

PhotoColumn     -- This represents a photo file located within the photo.zip archive or
                   the photo folder, if it is set to None then the photo is assumed to
                   named 'Photo_{memid}.jpg' within the zipfile.
MemIDColumn     -- This is used to represent the members number and will generate a new
                   number if set to None when the database is written to, otherwise it
                   is treated as an integer field.
DateColumn      -- This is used to represent date columns and stores the date in the
                   database as a string with the format 'YYYY-MM-DD', which is the
                   default that is generated by the datetime.date class.
DateTimeColumn  -- This is used to represent datetime columns and stores the datetime in
                   the database as a string with the format 'YYYY-MM-DDTHH:MM', which is
                   taken from the datetime.datetime class.
YearColumn      -- This is used to represent a year as an integer on the database, it
                   has a restricted range of values, but is otherwise treated like an
                   integer field.
TextColumn      -- This is used to represent text that is handles as a string in the
                   database, except that the length of the value that can be stored is
                   controlled, and trailing and leading whitespace are stripped before
                   storing the value.
PhoneColumn     -- This is used to represent phone numbers within the database which
                   are treated as strings, even though only digits are present.
MobileColumn    -- This is used to represent mobile phonne numbers within the database
                   which are treated as strings, even though only digits are present.
MoneyColumn     -- This is used to represent money through the real database type, it
                   will represent the values as with 2dp.
IntegerColumn   -- This is used to represent integer fields in the database, it prevents
                   the use of negative values, but is otherwise treated like an integer
                   field.
BoolColumn      -- This is used to represent a boolean field in the database, it permits
                   the value to be set to True or False.
EmailColumn     -- This is used to represent an email address field in the database, it
                   attempts to validate the address as valid, but otherwise it is handled
                   as a text field.
MapColumn       -- This is used to represent a mapping from an integer in the database to a
                   string representation within the UI.
'''

import re
##from datetime import date, datetime
import datetime
import decimal
from types import MethodType
##TODO from ..shared.pubsub import pub for generating events on data changes

from .errors import DatabaseValueError, DatabaseChangedError, DatabaseConvertError
from ..config.range import AbsDatabaseSettings
from ..shared.utils.absolute import AbsRange

class _FldChanged:
  '''This class provides information regarding which fields have been modified and also require validation'''
  def __init__(self, *args, **kwarg):
    self._changed = set()
    
  def anychanges(self):
    return len(self._changed) > 0

  def changed(self, field):
    self._changed.add(field)

  def donechange(self, field):
    self._changed.remove(field)

  def clear(self):
    self._changed.clear()

  def __contains__(self, field):
    return field in self._changed

  def __str__(self):
    return '_FldChanged(changed={0._changed})'.format(self)

class _BaseColumn:
  '''This is the base column in which all shared functionality is defined'''
  def __init__(self):
    if not hasattr(self, '_valtype'):
      raise TypeError("Missing '_valtype' attribute on column")
    if self._valtype is None:
      raise TypeError("Column has no useful datatype defined in '_valtype'")
    if not hasattr(self, '__next__'):
      if hasattr(self, '_defaultvalue'):
        if self._defaultvalue is not None and not isinstance(self._defaultvalue, self._valtype):
          raise TypeError("'_defaultvalue' is not an instance/subclass of '_valtype'")
      else:
        raise TypeError("Missing '_defaultvalue' attribute on column")
    if not hasattr(self, '_quoted'):
      raise TypeError("Missing '_quoted' attribute on column")
    if not isinstance(self._quoted, bool):
      raise TypeError("'_quoted' is not an instance of bool")
    if not hasattr(self, '_check') or self._check is None:
      self._check = self._dummy_check
    if not isinstance(self._check, MethodType):
      raise TypeError("'_check' is not a method on column")
    if hasattr(self, '_re') and not hasattr(self, '_re_convert'):
      raise TypeError("Missing '_re_convert' method if '_re' used on column")
    elif hasattr(self, '_convert') and not isinstance(self._convert, MethodType):
      raise TypeError("'_convert' is not a method on column")

  def _dummy_check(self, value, inst=None):
    'Dummy function that always returns True'
    return True

  def __set_name__(self, owner, name):
    'New protocol used by 3.6+ for descriptors'
    self._name = name
    setattr(owner, self._instname, None)
    if not hasattr(owner, '_fldict_'):
      setattr(owner, '_fldict_', dict())
    owner._fldict_[name] = self
    if not hasattr(owner, '_changed_flds_'):
      setattr(owner, '_changed_flds_', _FldChanged())

  def __get__(self, inst, objtype):
    value = getattr(inst, self._instname)
    if value is None:
      value = self._defaultvalue
    elif not isinstance(value, self._valtype):
      raise DatabaseValueError(inst, self._name, value)
    return value
    
  def __set__(self, inst, value):
    if self._instname in inst._changed_flds_:
      raise DatabaseChangedError(inst, self._name)
    elif value is None:
      try:
        value = next(self, None)
      except TypeError:
        value = None
      if value is None and not hasattr(self, '_defaultvalue'):
        raise DatabaseValueError(inst, self._name, value)
    elif isinstance(value, self._valtype):
      if not self._check(value, inst):
        raise DatabaseValueError(inst, self._name, value)
    elif hasattr(self, '_re'):
      if isinstance(value, str):
        match = self._re.match(value)
        if match is not None:
          oldvalue, value = value, self._re_convert(match, inst)
          if not self._check(value, inst):
            raise DatabaseConvertError(inst, self._name, value, oldvalue)
        else:
          raise DatabaseValueError(inst, self._name, value)
      else:
        raise DatabaseValueError(inst, self._name, value)
    elif hasattr(self, '_convert'):
      oldvalue, value = value, self._convert(value, inst)
      if value is None or not self._check(value, inst):
        raise DatabaseConvertError(inst, self._name, value, oldvalue)
    else:
      raise DatabaseValueError(inst, self._name, value)

    oldvalue = getattr(inst, self._instname)
    if oldvalue is None:
      pass
    elif not isinstance(oldvalue, self._valtype):
      raise DatabaseValueError(inst, self._name, oldvalue)
    elif not self._check(oldvalue, inst):
      raise DatabaseValueError(inst, self._name, oldvalue)

    if value != oldvalue:
      setattr(inst, self._instname, value)
      inst._changed_flds_.changed(self._name)

  def _as_sqlvalue(self, inst):
    'Return the current value as a valid SQL value according to the _quoted attribute'
    fmtstr = "'{}'" if self._quoted else '{}'
    fmtval = getattr(inst, self._name)
    return 'None' if fmtval is None else fmtstr.format(fmtval)

  @property
  def _instname(self):
    return '_' + self._name

class PhotoColumn(_BaseColumn):
  '''This is the photo column in which references to photos are stored'''
  _valtype = str
  _defaultvalue = None
  _quoted = True

  def _check(self, value, inst=None):
    # FIXME Add proper checks on the value
    return True

class MemIDColumn(_BaseColumn):
  '''This class represents a member ID whereby a new number is generated if the value is
     None when written back to the database, otherwise it is an integer value.'''
  _valtype = int
  _quoted = False

  def __next__(self):
    # FIXME Need to implement
    return None

  def _check(self, value, inst=None):
    if value is not None and value < 0:
      return False
    return True

class DateColumn(_BaseColumn):
  '''This is the date column in which dates are stored without any time part'''
  _valtype = datetime.date
  _quoted = True

  def _convert(self, value, inst=None):
    if not isinstance(value, str):
      raise DatabaseValueError(inst, self._name, value)
    return datetime.datetime.strptime(value, '%Y-%m-%d').date()

  @property
  def _defaultvalue(self):
    return datetime.date.today()

  def _check(self, value, inst=None):
    return AbsDatabaseSettings.Year.Check(value.year)

class DateTimeColumn(_BaseColumn):
  '''This is the datetime column in which dates are stored with time to minutes'''
  _valtype = datetime.datetime
  _quoted = True

  def _convert(self, value, inst=None):
    if not isinstance(value, str):
      raise DatabaseValueError(inst, self._name, value)
    return datetime.datetime.strptime(value, '%Y-%m-%d@%H:%M')
 
  @property
  def _defaultvalue(self):
    return datetime.datetime.today()

  def _check(self, value, inst=None):
    return AbsDatabaseSettings.Year.Check(value.year)

class YearColumn(_BaseColumn):
  '''This is the year column in which the values are integer which represent the year'''
  _valtype = int
  _quoted = False

  def _convert(self, value, inst=None):
    'Use the datetime.strptime function to handle conversion'
    if isinstance(value, int):
      if not AbsDatabaseSettings.Year.Check(value):
        raise DatabaseValueError(inst, self._name, value)
      return value
    if not isinstance(value, str):
      raise DatabaseValueError(inst, self._name, value)
    convalue = datetime.datetime.strptime(value, '%Y')
    return convalue.year
     
  @property
  def _defaultvalue(self):
    return datetime.date.today().year

  def _check(self, value, inst=None):
    return AbsDatabaseSettings.Year.Check(value)

class TextColumn(_BaseColumn):
  '''This is the text column which has a maximum length of value'''
  _valtype = str
  _defaultvalue = ''
  _quoted = True

  def __init__(self, length):
    super().__init__()
    if not isinstance(length, int):
      raise TypeError('Column length must be an integer')
    if not AbsDatabaseSettings.Text.Check(length):
      raise TypeError('Column length is not valid')
    self._validator = AbsRange(0, length)

  def _check(self, value, inst=None):
    if not isinstance(value, str):
      return False
    return self._validator.Check(len(value))

class PhoneColumn(_BaseColumn):
  '''This is the phone column which has restrictions on the value'''
  _valtype = str
  _defaultvalue = None
  _quoted = True

  def _check(self, value, inst=None):
    return True  # FIXME Add checks for validity of phone number 

class MobileColumn(PhoneColumn):
  '''This is the mobile column which has further restrictions on PhoneColumn'''

class MoneyColumn(_BaseColumn):
  '''This is the money column which enforces 2dp on all values'''
  _valtype = decimal.Decimal
  _defaultvalue = decimal.Decimal(0)
  _quoted = False

  def _check(self, value, inst=None):
    return 0.00 <= value 

class IntegerColumn(_BaseColumn):
  '''This is the integer column which prevents negative values'''
  _valtype = int
  _defaultvalue = 0
  _quoted = False

  def __init__(self, maxvalue=AbsDatabaseSettings.Integer.Max):
    super().__init__()
    if not isinstance(maxvalue, int) or maxvalue < 0:
      raise TypeError('MAXVALUE must be a non-negative int value')
    self._maxvalue = maxvalue

  def _check(self, value, inst=None):
    return 0 <= value <= self._maxvalue

class BoolColumn(_BaseColumn):
  '''This is the boolean column which predefines the values used'''
  _valtype = bool
  _defaultvalue = False
  _quoted = False

  def _check(self, value, inst=None):
    # This function always returns True since _valtype will catch problems
    return True

  def _as_sqlvalue(self, inst):
    'Override the default method to provide an explicit value'
    return '1' if getattr(inst, self._instname, False) else '0'

class EmailColumn(_BaseColumn):
  '''This is the email column which defines the valid email addresses'''
  _valtype = str
  _defaultvalue = None
  _quoted = True
  def _check(self, value, inst=None):
    return True  # FIXME Add appropriate checks

class MapColumn(_BaseColumn):
  '''This is the mapping column that maps an intger into a string equivalent'''
  _valtype = int
  _defaultvalue = 0
  _quoted = False

  def __init__(self, area):
    super().__init__()
    self._area = area

  def _check(self, value, inst=None):
    return True    # FIXME need to implement a valid check
      
if __name__ == '__main__':
  class Test:
    fld1 = DateColumn()
    fld2 = DateTimeColumn()
    fld3 = YearColumn()
    fld4 = TextColumn(30)
    fld5 = IntegerColumn(25)
    fld6 = BoolColumn()

  t = Test()
  t.fld1 = '2014-01-05'
  t.fld2 = '2016-03-03@18:50'
  t.fld3 = '2012'
  t.fld4 = 'This is under 25 char'
  t.fld5 = 20
  t.fld6 = True
  print(t._fields)
  print(getattr(t, 'fld6'))
